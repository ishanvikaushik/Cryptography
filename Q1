#Affine Cipher
def mod_inverse(a, m=26):
    for x in range(1, m):
        if (a * x) % m == 1:
            return x
    return None

def affine_encrypt(plaintext, a, b):
    ciphertext = ""
    for c in plaintext:
        if c.isalpha():
            num = ord(c.upper()) - 65
            num = (a * num + b) % 26
            ciphertext += chr(num + 65)
        else:
            ciphertext += c
    return ciphertext

def affine_decrypt(ciphertext, a, b):
    inv = mod_inverse(a)
    if inv is None:
        return "Error: Key a has no modular inverse, can't decrypt."
    plaintext = ""
    for c in ciphertext:
        if c.isalpha():
            num = ord(c.upper()) - 65
            num = (inv * (num - b)) % 26
            plaintext += chr(num + 65)
        else:
            plaintext += c
    return plaintext

plaintext = input("Enter the text to encrypt: ")
a = int(input("Enter key a (must be coprime with 26): "))
b = int(input("Enter key b (number): "))

#Caesar Cipher
def encrypt(plaintext,key):
    ciphertext=""
    for c in plaintext:
        num=ord(c)-65
        num=(num+key)%26
        ciphertext+=chr(num+65)
    return ciphertext

def decrypt(encrypted_text,key):
    text=""
    for c in encrypted_text:
        num=ord(c)-65
        num=(num-key)%26
        text+=chr(num+65)
    return text

def preprocess(text):
    result=""
    for c in text:
        if(c!=" "):
            result+=c.upper()
    return result

text=input("Enter text to encrypt:")
key=int(input("Enter key:"))
plaintext=preprocess(text)
encrypted_text=encrypt(plaintext,key)
print("This is encrypted:",encrypted_text)
decrypted=decrypt(encrypted_text,key)
print("Decrypted:",decrypted)

#Multiplicative cipher
def mod_inverse(a,m=26):
    for x in range(1,m):
        if (a*x)%26==1:
            return x
    return None

def encrypt(plaintext,key):
    ciphertext=""
    for c in plaintext:
        if c!=" ":
            if c.isalpha():
                num=ord(c.upper())-65
                num=(num*key)%26
                ciphertext+=chr(num+65)
            else:
                ciphertext+=c
    return ciphertext

def decrypt(encrypted_text,key):
    inv=mod_inverse(key)
    if inv is None:
        return "Error: Key has no modular inverse, can't decrypt."
    de_text=""
    for c in encrypted_text:
        if c.isalpha():
            num=ord(c.upper())-65
            num=(num*inv)%26
            de_text+=chr(num+65)
    return de_text

text=input("Enter text to encrypt:")
key=int(input("Enter key:"))
encrypted_text=encrypt(text,key)
print("This is encrypted:",encrypted_text)
decrypted=decrypt(encrypted_text,key)
print("Decrypted:",decrypted)
encrypted = affine_encrypt(plaintext, a, b)
decrypted = affine_decrypt(encrypted, a, b)

print("Encrypted:", encrypted)
print("Decrypted:", decrypted)
